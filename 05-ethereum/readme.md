# 以太坊

### 1.详细说明一下以太坊交易打包的过程

以太坊是一种区块链网络，它允许用户发送和接收以太币（ETH）以及其他代币，并在链上执行智能合约。这些交易需要被打包进区块中，并由矿工来验证和确认。

以下是以太坊交易打包的过程的详细说明：

- 创建交易：交易是由发送者创建并签名的。它包括发送方的以太币地址、接收方的以太币地址、交易金额以及一些可选的交易数据。

- 广播交易：交易需要被广播到网络上的所有节点。这可以通过将交易发送给一个节点，然后该节点将其广播给它所知道的其他节点。

- 交易池：交易被广播后，它们将进入待处理的交易池。在交易池中，交易会等待被打包到新的区块中。

- 打包交易：矿工会从交易池中选择一些交易，并将它们打包到新的区块中。矿工通常会选择交易费用（gas
  fee）最高的交易，因为他们可以从中获得更高的奖励。一旦矿工已经将交易打包进区块，它们就被认为是已经被确认并执行了。

- 确认交易：一旦新的区块被创建并添加到区块链上，其中包括新的交易，那么这些交易就被认为是已经被确认并执行了。

- 交易费用：交易费用是由发送方支付的，它是通过消耗一定量的gas来计算的。gas是以太坊网络中的计量单位，用于衡量执行交易所需的计算资源。矿工会收取这些交易费用作为奖励，以鼓励他们参与打包交易的过程。

总之，以太坊交易打包的过程涉及创建交易、广播交易、交易池、打包交易、确认交易以及交易费用。这个过程是自动化的，并且由区块链网络中的节点和矿工来执行。

### 2.以太坊为什么会分叉，遇到分叉钱包，layer2 类似的应用该怎么处理

### 3.以太坊底层用的数据结构是什么，可以详细说一下

以太坊底层使用了多种不同的数据结构，其中最重要的是Merkle Patricia Tree和状态数据库。

Merkle Patricia
Tree是一种高效的数据结构，用于存储和管理以太坊账户和交易的状态。它是一种树形结构，其中每个节点都包含一个哈希值和一个键值对。键值对用于存储账户地址、交易哈希等信息，而哈希值用于快速验证数据的完整性和一致性。Merkle
Patricia Tree被广泛应用于以太坊的账户状态树和交易状态树中。

另一个重要的数据结构是状态数据库。它是以太坊的全局状态存储，包括所有账户的余额、代码、存储和合约状态等信息。状态数据库的实现基于LevelDB，可以高效地存储和检索状态数据。

除此之外，以太坊还使用了其他数据结构，如Bloom Filter和B-Tree，用于优化区块链的性能和效率。Bloom
Filter用于快速检索一个元素是否存在于某个集合中，而B-Tree则是一种自平衡树，常用于数据库索引中。

### 4.以太坊的钱包使用的是哪些密码学算法，并简要说明一下这些算法的原理

### 5.简单说明一下以太坊的 gas 机制

### 6.了解以太坊的 EIP155 吗，它主要是为了解决什么问题而存在的

### 7.了解以太坊的 Eip712 吗，它主要是为了解决什么问题而存在的

EIP712是以太坊上的一种标准，它定义了一种消息结构和签名方法，用于在去中心化应用程序（DApp）中进行安全的消息验证和授权。

具体来说，EIP712允许DApp在不泄露私钥的情况下验证用户对某些操作的授权。它通过使用预定义的消息格式和签名方法，确保消息的完整性和身份验证，以及防止重放攻击和其他欺诈行为。

EIP712的另一个重要用途是使DApp能够与智能合约进行更安全、更直接的交互。通过使用EIP712标准定义的消息格式，智能合约可以验证来自DApp的消息，从而保护合约不受欺诈性攻击。

总之，EIP712为以太坊生态系统中的DApp和智能合约提供了一种安全且标准化的消息验证和授权方法。

### 8.了解 EIP1155 吗，它主要是为了解决什么问题而存在的

### 9. 简要说明 Ethereum 的 EVM 的底层运行机制

以太坊（Ethereum）的EVM（Ethereum Virtual Machine）是以太坊网络的核心组件之一，它是一个基于栈的虚拟机，为智能合约提供了运行环境。以下是EVM的底层运行机制的简要说明：

1.指令集：EVM采用了一组精简的指令集，包括算术操作、比较操作、逻辑操作、内存操作、栈操作等。每个指令都有一个操作码和一些操作数，当指令被执行时，EVM会从指令集中读取操作码，并按照操作数进行操作。

2.栈：EVM的操作是基于栈的，EVM中有一个栈，所有操作数都被压入栈中，而不是使用寄存器。栈的大小是固定的，不能调整，因此智能合约需要根据栈的大小进行编写。

3.存储：EVM中还有一个存储器，可以将数据存储在其中，存储器是按字（32字节）进行分配的。存储器可以通过合约的地址和存储器索引进行访问，每个存储器单元都有一个初始值为零。

4.内存：EVM还有一个内存区域，可以用来存储临时数据。EVM中的指令可以在内存中读取和写入数据，但是内存的大小是动态调整的，每次增加的大小是32个字节。

5.状态转换：当一个智能合约被调用时，EVM会将它的代码加载到内存中，并根据指令逐个执行。当执行指令时，EVM会改变合约的状态，例如更改存储器中的值、将数据压入栈中等。一旦智能合约执行完毕，EVM会将最终状态保存到以太坊区块链中。

### 10.EVM 存储器实现原理是什么

EVM（以太坊虚拟机）是以太坊区块链上的虚拟机，用于执行智能合约的代码。在 EVM 中，存储器是一个字节数组，用于在执行智能合约时存储临时数据。

EVM 存储器的实现原理如下：

存储器是一个由字节数组构成的内存空间。在 EVM 中，存储器的大小是以字节为单位的，最大大小为2^256个字节。

存储器是永久存储的，意味着在智能合约的生命周期内都可以被访问到。

存储器的每个字节都有一个唯一的索引值，称为存储器地址。存储器地址是一个以太坊地址，范围从0到2^256-1。

智能合约可以通过存储器地址访问存储器中的数据。存储器地址可以在智能合约的代码中直接使用，也可以通过函数参数传递。

存储器的读取和写入操作都是昂贵的操作，因此在智能合约中应该尽量减少存储器的使用量。

存储器的读取操作是免费的，但写入操作需要支付 gas 费用。写入操作的 gas 费用取决于写入的字节数。

总之，EVM
存储器是一个由字节数组构成的内存空间，用于在执行智能合约时存储临时数据。存储器地址唯一地标识存储器中的每个字节，智能合约可以通过存储器地址访问存储器中的数据。在智能合约中应该尽量减少存储器的使用量，因为读取和写入操作都是昂贵的操作。

### 11. 简要说明以太坊节点的区块打包机制

在以太坊网络中，每个区块包含一组交易，这些交易可以是普通交易或智能合约调用。当一个节点在以太坊网络上挖出一个新的区块时，它需要执行以下步骤来打包交易：

- 从交易池中选择一组待打包的交易，通常会选择交易费用最高的交易优先打包。

- 将这些交易按照一定的规则排序，以确保每个节点都有相同的交易排序，从而保证所有节点达成共识。

- 计算区块头的哈希值，并将其与交易数据一起写入新的区块中。

- 将新区块广播到整个网络，以便其他节点进行验证和确认。

在以太坊中，智能合约是用 Solidity 等高级编程语言编写的，并通过 EVM 运行。当智能合约被调用时，EVM
将会执行合约代码，并将结果写入区块链。智能合约调用也可以作为一个交易被打包到区块中。

### 12.以太坊的区块头的计算机制什么

以太坊的区块头计算机制是一种基于哈希的机制，它由以下几个部分组成：

- 父区块哈希：指向当前区块所在链中前一个区块的哈希值，用于保证区块链的不可篡改性。

- 状态根哈希：表示当前区块中所有账户状态的根哈希，用于确保在当前区块中发生的所有交易的合法性。

- 交易根哈希：表示当前区块中所有交易的哈希树根节点的哈希值，用于验证区块中所有交易的有效性。

- 时间戳：指定区块的创建时间戳，用于验证区块的时序性。

- 难度目标值：一个整数，用于限制当前区块的哈希值必须小于该值，从而保证当前区块的工作量证明符合网络规则。

这些组成部分会被整合在一起，通过哈希函数计算得出一个32字节的区块头哈希值，用于唯一标识该区块。区块链上的每个节点都可以使用这个哈希值来验证该区块的有效性，并将其添加到区块链中。

### 13.以太坊有哪些类型的节点，这些节点的使用场景是什么

### 14.EIP4484 是什么，请简要说明
EIP-4484 是以太坊的一项提案，全称为「引入 Blob 交易类型以支持 Danksharding」，主要目标是为以太坊的分片（Sharding）方案做准备，提升网络的数据存储和处理能力。
其核心内容是：
引入一种新的交易类型（Blob-carrying transactions），允许交易携带大量额外数据（称为 Blob）
这些 Blob 数据不直接存储在以太坊主链上，而是由网络节点临时保存（约 1-3 个月）
相比传统交易的 calldata，Blob 数据的 gas 成本更低，适合存储 Layer2（如 Rollup）提交的大量交易数据
该提案是实现 Danksharding（以太坊分片方案）的关键一步，能显著降低 Layer2 向主链提交数据的成本，提升整个以太坊生态的可扩展性。目前已被纳入以太坊「上海升级」后的路线图，是以太坊 scaling 计划的重要组成部分。

### 15.EIP4337 是什么，请简要说明

### 16.详细说一下以太坊的布隆过滤器

以太坊中的布隆过滤器（Bloom Filter）是一种用于快速检索数据的数据结构。它通常用于以太坊中的状态转换数据存储（State
Trie）中，以提高状态查询的效率。

布隆过滤器由一个位数组和一组哈希函数组成。位数组的长度是固定的，通常为几百万到几千万个比特。哈希函数将输入映射到位数组上的位置，并将该位置的值设置为
1。当查询某个元素时，将该元素输入到哈希函数中，如果所有哈希函数所对应的位置都为 1，则该元素可能在数据集中；否则，该元素一定不在数据集中。

以太坊的布隆过滤器被用于记录一个交易地址是否曾经被使用过。在区块中，每个交易都会包含一个发送者地址和一个接收者地址。当一个区块被处理时，所有交易的地址都被添加到布隆过滤器中。当以后需要查询某个地址是否曾经被使用过时，只需要将该地址输入到布隆过滤器中，如果所有哈希函数所对应的位置都为
1，则该地址可能被使用过；否则，该地址一定没有被使用过。

布隆过滤器的优点是可以快速判断一个元素是否在数据集中，而不需要遍历整个数据集。然而，由于哈希函数的存在，布隆过滤器有一定的误判率。如果一个元素被误判为在数据集中，可能会导致不必要的查询，降低系统性能。因此，在使用布隆过滤器时，需要权衡误判率和性能之间的关系，选择适当的参数配置。

##### 布隆过滤器的风险概览

|         风险          |   	原因    |    	影响     |      	缓解措施      |
|:-------------------:|:--------:|:----------:|:---------------:|
| 误报(False Positive)  |  	哈希冲突   | 	额外开销或错误判断 | 	增加位数组大小，优化哈希函数 |
|        无法删除	        |   位共享	   |  动态场景失效	   |    使用计数布隆过滤器    |
| 假阴性(False Negative) | 	位数组被篡改  |  	漏判关键数据	  |    保护位数组完整性     |
|        容量超载	        | 插入超出设计容量 |  	误报率失控	   |   预估容量或用可扩展版本   |
|       哈希函数质量	       |  分布不均匀   |   	性能下降    |   	选择高质量哈希函数    |
|        隐私泄露	        |  模式分析	   |    信息暴露    |   	提高误报率或加密键    |
|        不可逆性	        |  单向设计	   |  无法恢复数据	   |    配合其他数据结构     |
|        场景误用         | 	不匹配需求	  |    系统失效    |  	评估需求，选择合适工具   |

### 17. 如何防止布隆过滤器的误判

布隆过滤器的误判是由于哈希函数产生的冲突导致的。因此，为了减少误判的可能性，可以采取以下方法：

增加哈希函数的数量：增加哈希函数的数量可以减少冲突的概率，从而减少误判的可能性。

增加布隆过滤器的大小：增加布隆过滤器的大小可以使其能够容纳更多的元素，从而减少误判的可能性。

调整布隆过滤器的参数：可以根据具体情况调整布隆过滤器的参数，如哈希函数的种类、布隆过滤器的大小等。

组合多个布隆过滤器：可以将多个布隆过滤器组合起来使用，从而进一步降低误判的可能性。

结合其他数据结构：可以将布隆过滤器与其他数据结构结合使用，如红黑树、哈希表等，以提高准确性。

### 18.详细说一下 ETH Casper FFG共识机制

以太坊 Casper FFG (Friendly Finality Gadget) 共识机制是以太坊2.0升级后的一种混合共识机制。它结合了权益证明 (Proof of
Stake, PoS) 和工作量证明 (Proof of Work, PoW) 两种算法的优势，旨在提高网络的安全性、可扩展性和去中心化程度。

在 Casper FFG 中，验证节点需要锁定一定数量的以太币 (ETH) 作为抵押品，来获得参与记账的资格。这些验证节点称为验证人，他们的任务是验证交易并打包区块。与纯
PoS 不同，Casper FFG 仍然需要 PoW 矿工来生产区块，但他们不再直接产生新的以太币，而是获取交易手续费作为奖励。

Casper FFG 引入了一个称为 "权益投票" (bonded validator voting)
的概念。验证人可以选择对一个区块进行投票，以表明他们是否认可该区块。如果超过2/3的权益 (即抵押的以太币数量)
支持某个区块，那么该区块被认为是最终确认的，交易也将被确定为不可逆转。这就是所谓的 "最终性" (finality)，它是 PoS
算法的一个重要特征，可以保证网络的安全性。

Casper FFG 还引入了一个称为 "惩罚机制" (punitive mechanism)
的概念。如果验证人表现不佳或故意作恶，他们可能会失去抵押的以太币，这就是所谓的 "抵押惩罚" (slashing)
。如果验证人投票支持两个相互矛盾的区块，也会被惩罚。这种惩罚机制可以有效地防止验证人的不端行为，维护网络的安全性和稳定性。

总的来说，Casper FFG 的目标是在提高以太坊网络的安全性和可扩展性的同时，保持其去中心化的特性。

### 19.信标链的 epoch 和 slot 分别代表什么，一个 epoch 包含多少个 slot

信标链是以太坊2.0中的一条主要链，它采用了 PoS 共识机制。在信标链中，时间被划分为一系列 epoch 和 slot。

一个 epoch 指的是一段时间，它由一定数量的 slot 组成。在信标链中，每个 epoch 的持续时间为 6.4 分钟，每个 slot 的持续时间为 12
秒。因此，一个 epoch 包含 32 个 slot。

在信标链中，每个 slot 都由一个验证人组成，验证人需要在每个 slot 中进行验证工作并打包区块。随着时间的推移，验证人会轮流参与不同的
slot，以确保网络的安全性和去中心化程度。

通过划分时间为 epoch 和 slot，信标链可以实现更高效的共识机制，同时也方便验证人进行轮流验证工作。

### 19.信标链区块在什么状态下是不可逆转的

在信标链中，一个区块在满足以下条件时被认为是不可逆转的：

区块必须被完全确认：一个区块被认为是完全确认的，需要满足所有验证人在该区块上的投票结果已经被记录在链上，并且投票结果中超过2/3的验证人已经确认了该区块。

区块必须在一个最终性 epoch 中：一个最终性 epoch 是一个已经被确认的 epoch，其中每个 slot 都已经被投票确认，并且至少有 2/3
的验证人参与了投票。只有在最终性 epoch 中的区块才被认为是不可逆转的，因为它们已经获得了足够的确认和支持。

因此，只有在一个已经完成最终性投票的 epoch 中，包含一个完全确认的区块才是不可逆转的。在这种情况下，该区块被视为区块链上的最终状态，其中的交易将无法被更改或撤销。

### 20.信标链的攻击成本怎么计算

恢复一个已最终确认的区块需要至少 1/3 的验证者烧掉他们的存款，根据这个公式计算一下攻击成本：
攻击成本：1/3 * (验证者数量 * 32) * ETH/USDT架构

### 21.对于钱包和 layer2 应用来说，信标链充提安全高度怎么设定比较合适

### 22. 简述 EIP-3651 的作用

说到 EIP-3651，得先介绍一下 EIP-2929 一个改动：当目标不在 accessed_addresses 中，收取
COLD_ACCOUNT_ACCESS_COST（冷账户访问成本）gas，并将地址添加到 accessed_addresses。否则，收取
WARM_STORAGE_READ_COST（暖存储读取成本）gas，暖读取消耗 gas 相对较低。

如今 COINBASE 直接支付正变得越来越受欢迎，但目前访问 COINBASE 的价格较高；这是由于在 EIP -2929 引入的访问列表框架下，COINBASE
是按冷账户访问成本计算 gas 的，在 EIP-3651 后，accessed_addresses 将包括 COINBASE (0x41) 返回的地址。

好处：修改后，COINBASE 在支付 ERC20 代币时会减少 gas 消耗。

### 23. 简述 EIP-3855 的作用

EIP-3855，引入一条新指令（0x5f），将常量值 0 压入堆栈，黄皮书关于 PUSH 的指令集，目前只有 PUSH1-PUSH32，作用是将 1 字节压入堆栈，到
32 字节压入堆栈

现有指令实现将 0 值压入堆栈需要通过执行 PUSH1 0 ，在 runtime 中需要消耗 3 gas，并且额外需要消耗 200 gas（2 字节的存储成本）

有了 PUSH0 指令后，就不需要消耗这额外的 200 gas了。

好处：目前大约有 11% 的 PUSH 操作只是压入 0，因此这个 EIP 执行后可以节省一定量的 gas，也能稍微提高以太坊的现有的 TPS。

### 24. 简述 EIP-3860 的作用

目前 initcode 的最大为 MAX_CODE_SIZE: 24576（EIP-170），新的 initcode 的最大为 (MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE =
49152)，这意味合约大小可以扩展一倍，合约开发者可以部署更丰富的功能。（合约代码过大会导致部署不成功，PS：L2
项目也部分已修改，支持更高的合约大小上限）

此外为每 32 字节的 initcode chunk引入 2 个 gas 费用，以表示 jumpdest-analysis 的成本。因为在合约创建期间，客户端必须在执行之前对
initcode 执行 jumpdest 分析。执行工作与 initcode 的大小成线性关系。

这意味着 initcode 每字节将添加成本 0.0625 gas，合约部署 gas 成本微微上涨。

好处：合约部署 gas 费微微上调，但合约大小可以扩展一倍，合约开发者写更丰富的功能代码。

### 25. 简述 EIP-4895 的作用

主要内容是确定信标链提款至 EVM 的主要流程，部署完成后，以太坊信标链质押提款功能将被激活。

好处：激活以太坊信标链质押提款功能。

### 26. 以太坊的状态树，交易树，区块树和存储树解释

状态树是以太坊中最重要的数据结构之一，它用于存储以太坊网络中的所有账户状态。每个以太坊账户都有一个与之对应的状态条目，其中包括账户地址、余额、代码和存储数据等信息。状态树是一棵Merkle-Patricia树，它将所有账户状态存储在树中的叶子节点。每个叶子节点包含一个账户状态的哈希值，这个哈希值是由账户的地址和其它状态数据计算得到的。通过状态树，以太坊网络可以快速验证一个账户的状态是否合法。

状态树(State Trie)
：状态树是以太坊中最重要的数据结构之一，它用于存储以太坊网络中的所有账户状态。每个以太坊账户都有一个与之对应的状态条目，其中包括账户地址、余额、代码和存储数据等信息。状态树是一棵Merkle-Patricia树，它将所有账户状态存储在树中的叶子节点。每个叶子节点包含一个账户状态的哈希值，这个哈希值是由账户的地址和其它状态数据计算得到的。通过状态树，以太坊网络可以快速验证一个账户的状态是否合法。，通过对每个账户的nonce（用于防止交易重播）和余额、合约代码等信息进行哈希计算，来构建整个状态树。

交易树(Transaction Trie)
：用于存储所有交易的Merkle树结构，每个叶子节点代表一笔交易的哈希值，每个父节点代表它下面的两个子节点的哈希值的哈希值。这个树结构可以用于验证交易是否在某个区块中存在，以及验证交易的正确性。

区块树(Block Trie)：也是一个Merkle
Patricia树，用于存储所有区块的哈希值。每个叶子节点代表一个区块的哈希值，每个父节点代表它下面的两个子节点的哈希值的哈希值。这个树结构可以用于验证区块是否有效，以及验证区块是否属于以太坊的主链。

存储树(Storage Trie)：用于存储以太坊合约中的数据，包括变量、映射和数组等。存储树是一个Merkle
Patricia树，每个节点代表一个键值对。这个树结构可以用于验证合约数据的正确性和完整性。




